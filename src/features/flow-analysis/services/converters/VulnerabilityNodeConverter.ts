import { v4 as uuidv4 } from 'uuid';

import { AttackFlowNode, FlowEdge } from '../../types/attack-flow';
import { ExtractedAttackInfo } from '../types';

import { INodeConverter } from './base/INodeConverter';

export class VulnerabilityNodeConverter implements INodeConverter {
  async convertNodes(
    extractedInfo: ExtractedAttackInfo,
    existingNodes: AttackFlowNode[],
    existingEdges: FlowEdge[]
  ): Promise<{ nodes: AttackFlowNode[]; edges: FlowEdge[] }> {
    const nodes: AttackFlowNode[] = [...existingNodes];
    const edges: FlowEdge[] = [...existingEdges];
    
    console.log('=== Creating Vulnerability Nodes ===');
    
    extractedInfo.vulnerabilities?.forEach((vuln, index) => {
      // Only create nodes for vulnerabilities with CVE identifiers
      const cvePattern = /CVE-\d{4}-\d+/i;
      const hasCVE = vuln.name.match(cvePattern) || vuln.cve_id?.match(cvePattern);
      
      if (!hasCVE) {
        console.log(`Skipping non-CVE vulnerability: ${vuln.name} (no CVE identifier)`);
        return;
      }
      
      const id = `vulnerability-${index}`;
      
      nodes.push({
        id,
        type: 'vulnerability',
        spec_version: '2.1',
        name: vuln.name,
        description: vuln.description,
        cve_id: vuln.cve_id,
        cvss_score: vuln.cvss_score,
        source_snippet: vuln.source_snippet || '',
        confidence: vuln.confidence || 'medium',
      });
      
      console.log(`Created vulnerability node: ${vuln.name} (${vuln.cve_id || 'CVE from name'})`);
      
      this.connectVulnerabilityToAssets(vuln, id, nodes, edges);
      this.connectVulnerabilityToActions(vuln, id, nodes, edges);
    });
    
    return { nodes, edges };
  }
  
  private connectVulnerabilityToAssets(vuln: any, vulnId: string, nodes: AttackFlowNode[], edges: FlowEdge[]): void {
    vuln.affects_assets?.forEach((assetName: string) => {
      const assetNode = nodes.find(n => n.type === 'asset' && n.name === assetName);
      if (assetNode) {
        edges.push({
          id: uuidv4(),
          source: vulnId,
          target: assetNode.id,
          label: 'Affects'
        });
        console.log(`Vulnerability "${vuln.name}" affects asset "${assetName}"`);
      }
    });
  }
  
  private connectVulnerabilityToActions(vuln: any, vulnId: string, nodes: AttackFlowNode[], edges: FlowEdge[]): void {
    vuln.exploited_by?.forEach((techniqueId: string) => {
      const actionNode = nodes.find(n => n.type === 'attack-action' && n.technique_id === techniqueId);
      if (actionNode) {
        edges.push({
          id: uuidv4(),
          source: vulnId,
          target: actionNode.id,
          label: 'Exploited by'
        });
        console.log(`Vulnerability "${vuln.name}" exploited by action "${actionNode.name}"`);
      }
    });
  }
}